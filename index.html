<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M-Cyrillic Protocol IDE | Shima Hikari</title>
    <style>
        :root {
            --bg: #0d1117; --text: #c9d1d9; --accent: #58a6ff; --secondary: #8b949e;
            --code-bg: #161b22; --border: #30363d; --success: #238636; --danger: #f85149;
            --warn: #d29922; --info: #a5d6ff; --adj: #ff7b72;
            --halo-glow: 0 0 10px rgba(88, 166, 255, 0.4);
        }
        body { font-family: 'Segoe UI', "Hiragino Kaku Gothic ProN", sans-serif; background-color: var(--bg); color: var(--text); line-height: 1.6; margin: 0; }
        
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; display: grid; grid-template-columns: 240px 1fr; gap: 30px; }
        .sidebar { position: sticky; top: 20px; height: calc(100vh - 40px); border-right: 1px solid var(--border); padding-right: 20px; overflow-y: auto; }
        
        .logo-area { text-align: center; margin-bottom: 30px; border-bottom: 1px solid var(--border); padding-bottom: 20px; }
        .logo-text { font-family: monospace; font-weight: bold; color: var(--accent); text-shadow: var(--halo-glow); font-size: 1.1rem; }
        nav ul { list-style: none; padding: 0; }
        nav a { color: var(--secondary); text-decoration: none; display: block; padding: 8px; font-size: 0.9rem; transition: 0.2s; }
        nav a:hover { color: var(--accent); background: rgba(88,166,255,0.1); border-radius: 4px; }

        .section { margin-bottom: 40px; background: var(--code-bg); padding: 25px; border-radius: 8px; border: 1px solid var(--border); }
        h2 { color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 10px; font-family: monospace; }
        h1 { color: var(--accent); font-size: 1.5rem; }
        
        table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 0.85rem; }
        th, td { border: 1px solid var(--border); padding: 10px; text-align: left; }
        th { background-color: #21262d; }
        
        .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        textarea, select, input { width: 100%; background: #000; border: 1px solid var(--border); color: #fff; padding: 10px; border-radius: 4px; box-sizing: border-box; margin-bottom: 5px; }
        
        .trans-display { background: #000; border: 1px dashed var(--accent); color: var(--accent); padding: 20px; text-align: center; font-size: 1.8rem; font-family: 'Courier New', monospace; margin-top: 10px; min-height: 40px; }
        button { background: var(--accent); color: #000; border: none; padding: 12px; cursor: pointer; font-weight: bold; width: 100%; border-radius: 4px; transition: 0.2s; margin-top: 5px; }
        button:hover { opacity: 0.9; box-shadow: var(--halo-glow); }
        
        .btn-delete { background: transparent; color: var(--danger); border: 1px solid var(--danger); padding: 2px 8px; width: auto; font-size: 0.7rem; margin-top: 0; }
        .btn-delete:hover { background: var(--danger); color: white; }
        .btn-reset { background: transparent; color: var(--secondary); border: 1px solid var(--secondary); font-size: 0.8rem; }

        .badge { font-size: 0.7rem; padding: 2px 5px; border-radius: 3px; background: #30363d; vertical-align: middle; margin-right: 5px; font-family: monospace; }
        .save-status { font-size: 0.7rem; color: var(--success); text-align: center; margin-top: 5px; }
        
        /* 文法要素の説明用 */
        .grammar-tag { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; margin-right: 5px; margin-bottom: 5px; border: 1px solid var(--border); }
    </style>
</head>
<body>

<div class="container">
    <aside class="sidebar">
        <div class="logo-area">
            <div class="logo-text">MILLENNIUM<br>M-CYRILLIC IDE</div>
            <div style="font-size: 0.7rem; color: var(--secondary); margin-top:10px;">PROTOCOL v3.5<br>FULL LOGIC & SAVE</div>
            <div id="save-status" class="save-status">● Auto-Save Active</div>
        </div>
        <nav>
            <p style="font-size: 0.7rem; color: var(--accent);">-- DOCUMENTATION</p>
            <ul>
                <li><a href="#overview">00. 概要 (Overview)</a></li>
                <li><a href="#phonology">01. 音韻論 (Phonology)</a></li>
                <li><a href="#syntax">02. 統語論 (Syntax)</a></li>
                <li><a href="#logic">03. 論理構造 (Logic)</a></li>
            </ul>
            <p style="font-size: 0.7rem; color: var(--accent); margin-top:20px;">-- TERMINAL</p>
            <ul>
                <li><a href="#translator">論理演算ターミナル</a></li>
                <li><a href="#dictionary">辞書 & データ管理</a></li>
            </ul>
        </nav>
    </aside>

    <main class="main-content">
        <section id="overview" class="section">
            <h1>00. 概要定義</h1>
            <p><strong>言語名称：</strong> Metric-Cyrillic (M-Cyrillic / メトリック・キリル)</p>
            <p><strong>開発者：</strong> 島 ヒカリ (Millennium Science School)</p>
            <p>本言語は、スラブ語派のキリル文字を記号として採用し、物理学的な演算子構造（ポーランド記法）を文法に取り入れた人工言語である。</p>
        </section>

        <section id="phonology" class="section">
            <h1>01. 音韻論 (Phonology)</h1>
            <p>音素は物理定数のような硬質感を持つ。</p>
            <h3>母音体系</h3>
            <table>
                <tr><th>文字</th><th>IPA</th><th>物理的意味</th></tr>
                <tr><td>А</td><td>/a/</td><td>開放・エネルギー (慣性格)</td></tr>
                <tr><td>И</td><td>/i/</td><td>指向性・ベクトル (属性/形容)</td></tr>
                <tr><td>У</td><td>/u/</td><td>質量・重力</td></tr>
                <tr><td>Э</td><td>/e/</td><td>定義・等号</td></tr>
                <tr><td>О</td><td>/o/</td><td>空間・包含 (作用格/副詞)</td></tr>
                <tr><td>Ы</td><td>/ɨ/</td><td>虚数・仮定 (If/Else)</td></tr>
            </table>
        </section>

        <section id="syntax" class="section">
            <h1>02. 統語論 (Syntax)</h1>
            <p>VSO（動詞-主語-目的語）を基本とし、接頭辞・接尾辞により論理を修飾する。</p>
            <div style="background:var(--code-bg); padding:10px; border:1px solid var(--border); font-family:monospace;">
                [接続詞] [接頭辞-動詞+時制] [副詞] [主語+格] [形容詞] [目的語+格]
            </div>
        </section>

        <section id="logic" class="section">
            <h1>03. 論理構造 & 拡張文法</h1>
            <p>v3.5にて実装された拡張ロジック定義。</p>
            
            <h3>条件分岐 (If Statement)</h3>
            <p>「もし (If)」が存在する場合、文頭に接続詞 <code class="language-cyrillic">Иф</code> を配置し、動詞の時制を仮定相 <code class="language-cyrillic">-ы</code> に変更する。</p>
            
            <h3>疑問プロトコル (Interrogative)</h3>
            <p>「？ (Question)」を検知した場合、動詞に接頭辞 <code class="language-cyrillic">Ли-</code> を付与し、解の要求（Query）であることを宣言する。</p>

            <h3>修飾構造 (Modifiers)</h3>
            <ul>
                <li><span class="grammar-tag" style="border-color:var(--adj); color:var(--adj)">形容詞</span> 語根に <strong>-и</strong> を付与。変数の性質を定義する。</li>
                <li><span class="grammar-tag" style="border-color:var(--warn); color:var(--warn)">副詞</span> 語根に <strong>-о</strong> を付与。関数の実行速度や精度を定義する。</li>
            </ul>
        </section>

        <section id="translator" class="section" style="border: 1px solid var(--accent);">
            <h2>論理演算ターミナル (Translate)</h2>
            <p style="font-size:0.8rem; color:var(--secondary);">日本語を入力してください。論理構造（If文、疑問文、過去形など）を自動解析します。</p>
            <textarea id="jp-input" placeholder="例：私は毎朝ご飯を食べる" oninput="autoTranslate()"></textarea>
            <div class="trans-display" id="m-output">// STANDBY</div>
            <div id="log" style="font-size: 0.75rem; color: var(--secondary); margin-top: 10px; font-family: monospace;"></div>
        </section>

        <section id="dictionary" class="section">
            <h2>辞書データベース & ストレージ管理</h2>
            <div class="tool-grid">
                <div style="max-height: 500px; overflow-y: auto; border: 1px solid var(--border);">
                    <table>
                        <thead><tr><th>種別</th><th>語根 (Кур)</th><th>意味</th><th>操作</th></tr></thead>
                        <tbody id="dict-body"></tbody>
                    </table>
                </div>

                <div>
                    <h3>個別データ登録</h3>
                    <select id="new-type">
                        <option value="verb">動詞 (Action)</option>
                        <option value="noun">名詞 (Entity)</option>
                        <option value="adj">形容詞 (Attribute)</option>
                        <option value="adv">副詞 (Modifier)</option>
                        <option value="conj">接続詞 (Logic)</option>
                    </select>
                    <input type="text" id="new-root" placeholder="語根 (キリル文字表記)">
                    <input type="text" id="new-mean" placeholder="意味 (日本語)">
                    <button onclick="addWord()">データベースに追加</button>

                    <h3 style="margin-top:20px;">一括インポート</h3>
                    <div class="import-area">
                        <label style="font-size: 0.75rem; color: var(--secondary);">例：種類：形容詞 語根：Ю | 意味：美しい</label>
                        <textarea id="bulk-input" style="height: 100px; margin-top: 5px;" placeholder="ここにリストを貼り付け..."></textarea>
                        <button onclick="bulkImport()" style="background: var(--success); color: white;">一括インポート実行</button>
                    </div>
                    
                    <button class="btn-reset" onclick="clearStorage()" style="margin-top:30px;">[注意] 全データを初期化</button>
                </div>
            </div>
        </section>
    </main>
</div>

<script>
    // --- 1. ストレージ & 初期データ定義 ---
    const STORAGE_KEY = 'm_cyrillic_v3_5_data';
    
    // デフォルト辞書（初回起動時のみ使用）
    const defaultDict = {
        verbs: [
            {id:1, root:"Ген", mean:"生成"}, {id:2, root:"Скан", mean:"解析"},
            {id:3, root:"Либ", mean:"好き"}, {id:4, root:"Лог", mean:"記録"}
        ],
        nouns: [
            {id:101, root:"Кляйн", mean:"私"}, {id:102, root:"Наблю", mean:"先生"},
            {id:103, root:"Сист", mean:"システム"}, {id:104, root:"Ду", mean:"貴方"}
        ],
        adjs: [
            {id:201, root:"Ю", mean:"美しい"}, {id:202, root:"Бри", mean:"速い"},
            {id:203, root:"Гран", mean:"大きい"}
        ],
        advs: [
            {id:301, root:"Зен", mean:"完全に"}, {id:302, root:"Сло", mean:"ゆっくり"}
        ],
        conjs: [
            {id:401, root:"Иф", mean:"もし"}, {id:402, root:"Иф", mean:"なら"} // "なら"もLogic的にはIf
        ]
    };

    // ストレージから読み込み or デフォルト使用
    let dictionary = JSON.parse(localStorage.getItem(STORAGE_KEY)) || defaultDict;

    // --- 2. データ保存 & UI更新 ---
    function save() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(dictionary));
        const now = new Date();
        document.getElementById('save-status').innerText = `● Auto-Save: ${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;
    }

    function refreshUI() {
        const tbody = document.getElementById('dict-body');
        tbody.innerHTML = '';
        
        // 各カテゴリの定義と色設定
        const categories = [
            { key: 'verbs', label: '動', color: '#d2a8ff' }, // 紫
            { key: 'nouns', label: '名', color: '#7ee787' }, // 緑
            { key: 'adjs', label: '形', color: '#ff7b72' },  // 赤
            { key: 'advs', label: '副', color: '#d29922' },  // 黃
            { key: 'conjs', label: '接', color: '#a5d6ff' }  // 青
        ];

        categories.forEach(cat => {
            const list = dictionary[cat.key] || [];
            list.forEach(item => {
                tbody.innerHTML += `<tr>
                    <td><span class="badge" style="color:${cat.color}">${cat.label}</span></td>
                    <td style="font-family:monospace; font-weight:bold;">${item.root}</td>
                    <td>${item.mean}</td>
                    <td><button class="btn-delete" onclick="deleteWord('${cat.key}', ${item.id})">削除</button></td>
                </tr>`;
            });
        });
        save(); // 画面更新のたびに保存
    }

    // --- 3. データ操作ロジック ---
    function addWord() {
        const type = document.getElementById('new-type').value + 's'; // verbs, nouns...
        const root = document.getElementById('new-root').value.trim();
        const mean = document.getElementById('new-mean').value.trim();
        
        if(root && mean) {
            if(!dictionary[type]) dictionary[type] = [];
            dictionary[type].push({ id: Date.now(), root, mean });
            document.getElementById('new-root').value = '';
            document.getElementById('new-mean').value = '';
            refreshUI();
            autoTranslate();
        }
    }

    function deleteWord(type, id) {
        if(dictionary[type]) {
            dictionary[type] = dictionary[type].filter(item => item.id !== id);
            refreshUI();
            autoTranslate();
        }
    }

    function clearStorage() {
        if(confirm("警告：すべての辞書データを消去して初期状態に戻しますか？")) {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        }
    }

    function bulkImport() {
        const text = document.getElementById('bulk-input').value;
        const lines = text.split('\n');
        let count = 0;

        lines.forEach(line => {
            if(!line.trim()) return;
            const typeMatch = line.match(/種類[:：]\s*(動詞|名詞|形容詞|副詞|接続詞)/);
            const rootMatch = line.match(/語根[:：]\s*([^\s\|]+)/);
            const meanMatch = line.match(/意味[:：]\s*([^\s\n]+)/);

            if (typeMatch && rootMatch && meanMatch) {
                const map = { '動詞':'verbs', '名詞':'nouns', '形容詞':'adjs', '副詞':'advs', '接続詞':'conjs' };
                const key = map[typeMatch[1]];
                if(key) {
                    if(!dictionary[key]) dictionary[key] = [];
                    dictionary[key].push({ id: Date.now() + Math.random(), root: rootMatch[1], mean: meanMatch[1] });
                    count++;
                }
            }
        });
        
        if(count > 0) {
            alert(`${count}件 インポート完了`);
            document.getElementById('bulk-input').value = '';
            refreshUI();
            autoTranslate();
        }
    }

    // --- 4. 翻訳・論理構築エンジン (Core Logic) ---
    function autoTranslate() {
        const input = document.getElementById('jp-input').value;
        if(!input) { document.getElementById('m-output').innerText = "// STANDBY"; return; }

        let v = "", s = "", o = "";     // 動詞, 主語, 目的語
        let adj_s = "", adj_o = "";     // 形容詞
        let adv = "";                   // 副詞
        let conj = "";                  // 接続詞
        let prefix = "";                // 接頭辞 (疑問など)
        let tense = "т";                // 時制 (デフォルト:確定/過去)
        let logicLog = [];              // ログ用

        // A. 構文解析 (Syntax Parsing)
        if(input.includes("？") || input.includes("?")) {
            prefix = "Ли-";
            logicLog.push("[Query Mode]");
        }

        // B. 条件分岐 (If Logic)
        if(input.includes("もし") || input.includes("なら") || input.includes("if")) {
            tense = "ы"; // 仮定相
            if(!conj) conj = "Иф "; // もし接続詞が特定できなくてもIfを付与
            logicLog.push("[Hypothetical Logic]");
        } else if (input.includes("だろう") || input.includes("未来")) {
            tense = "м"; // 未確定相
            logicLog.push("[Future/Probabilistic]");
        }

        // C. 辞書スキャン (Lexical Scan)
        
        // 1. 接続詞
        (dictionary.conjs || []).forEach(c => {
            if(input.includes(c.mean)) conj = c.root + " ";
        });

        // 2. 副詞 (文全体 or 動詞修飾)
        (dictionary.advs || []).forEach(a => {
            if(input.includes(a.mean)) adv = a.root + "о "; // 接尾辞 -o
        });

        // 3. 名詞 (主語・目的語の判定)
        (dictionary.nouns || []).forEach(n => {
            // 日本語の助詞で判定
            if(input.includes(n.mean + "が") || input.includes(n.mean + "は")) s = n.root + "а"; // 慣性格 -a
            if(input.includes(n.mean + "を") || input.includes(n.mean + "に")) o = n.root + "он"; // 作用格 -on
        });

        // 4. 形容詞 (簡易ロジック: 入力文にある形容詞を検出)
        // 本来は「どの名詞にかかるか」の構文解析が必要だが、ここでは検出した順に割り当てる簡易実装
        (dictionary.adjs || []).forEach(a => {
            if(input.includes(a.mean)) {
                // 主語があり、まだ修飾がないなら主語につける、そうでなければ目的語につける
                if(s && !adj_s) adj_s = a.root + "и ";
                else if(o && !adj_o) adj_o = a.root + "и ";
            }
        });

        // 5. 動詞
        (dictionary.verbs || []).forEach(ver => {
            if(input.includes(ver.mean)) v = ver.root;
        });

        // D. 組み立て (Assembly)
        // [Conj] [Prefix-Verb-Tense] [Adv] [Adj-Subject] [Adj-Object]
        if(v && s && o) {
            // 語順: 接続詞 + (接頭辞+動詞+時制) + 副詞 + (形+主語) + (形+目的語)
            let result = `${conj}${prefix}${v}${tense} ${adv}${adj_s}${s} ${adj_o}${o}.`;
            document.getElementById('m-output').innerText = result;
            
            // ログ出力
            let detail = `Func: ${prefix}${v}(${tense}) | Args: [${s}], [${o}]`;
            if(adv) detail += ` | Mod: ${adv}`;
            document.getElementById('log').innerText = `Logic Trace: ${logicLog.join(" ")} ${detail}`;
        } else {
            document.getElementById('m-output').innerText = "...解析中 (V, S, O 不足)";
            document.getElementById('log').innerText = "主語、目的語、動詞の3要素が必要です。";
        }
    }

    // 初期化実行
    refreshUI();
</script>
</body>
</html>
